import { Box, Button, Center, Divider, Flex, Image, Input, Stack, Textarea, useBreakpointValue, useToast } from "@chakra-ui/react";
import { NextPage } from "next";
import Head from "next/head";
import { useRouter } from 'next/router';
import { Configuration, OpenAIApi } from "openai";
import React, { useState } from "react";
import { v4 } from 'uuid';
import DeletableOption from "../../../components/DeletableOption";
import { ImageUpload } from "../../../components/ImageUpload/ImageUpload";
import { GetOneRecipeDocument, IngredientInputType, Recipe, useAddNewRecipeMutation, useGetOneRecipeQuery, useWhoAmIQuery } from "../../../generated/graphql";
import { initializeApollo } from "../../../utils/apollo";
import getIngredientsData from "../../../utils/getIngredientsData";
import styles from "../../../styles/create-recipe.module.css";

interface Props {
  recipe: Recipe,
  savedStatus: boolean
}

const config = new Configuration({
  apiKey: process.env.NEXT_PUBLIC_OPENAI_KEY,
})

const openai = new OpenAIApi(config)

const EditRecipe: NextPage<Props> = ({ recipe }) => {
  // Hooks
  const toast = useToast()
  const router = useRouter()
  const apolloClient = initializeApollo()

  // Queries and Mutations
  const { data: whoami } = useWhoAmIQuery();
  const [addNewRecipe] = useAddNewRecipeMutation();


  // Manual State
  const [recipeName, setRecipeName] = useState(recipe.recipe_title)
  const [recipeDescription, setRecipeDescription] = useState(recipe.recipe_desc)
  const [cookTime, setCookTime] = useState(recipe.cook_time_minutes.toString())
  const [prepTime, setPrepTime] = useState(recipe.prep_time_minutes.toString())
  const [imageUploaded, setImageUploaded] = useState(false)
  const [imageChange, setImageChange] = useState(false);

  // Manual / Automatic State
  const [ingredients, setIngredients] = useState<IngredientInputType[]>([])
  const [quantity, setQuantity] = useState("")
  const [ingredientName, setIngredientName] = useState("")
  const [unit, setUnit] = useState("")
  const [instructions, setInstructions] = useState<string[]>([])
  const [step, setStep] = useState("")
  const [footnotes, setFootnotes] = useState<string[]>(recipe.footnotes)
  const [footnote, setFootnote] = useState("")


  // Loading Indicator State
  const [autoIngredienstLoading, setAutoIngredienstLoading] = useState(false)
  const [autoInstructionsLoading, setAutoInstructionsLoading] = useState(false)

  // Auto-gerated Indicator State
  const [autoGeneratedIngredients, setAutoGeneratedIngredients] = useState(false)
  const [autoGeneratedInstructions, setAutoGeneratedInstructions] = useState(false)

  //UUID gen for image upload
  const [uuidState, setUuidState] = useState(v4());

  // Ingredient Functions
  const addIngredient = (event: any) => {
    event.preventDefault()
    if (ingredientName === "" || quantity === "") {
      return
    }
    if (ingredients.find(ingredient => ingredient.ingredient === ingredientName)) {
      return
    }
    setIngredients([...ingredients, { ingredient: ingredientName, unit, quantity }])
    setQuantity("")
    setIngredientName("")
    setUnit("")
    warnChangedIngredient()
  }
  const deleteIngredient = (input: IngredientInputType) => {
    setIngredients(ingredients.filter(ingredient => ingredient.ingredient !== input.ingredient))
    warnChangedIngredient()
  }
  const editIngredient = (input: { property: string, value: string, index: number } | { index: number, substitution: IngredientInputType }) => {
    if (typeof input === "string") {
      const { index, substitution } = JSON.parse(input) as { index: number, substitution: IngredientInputType }
      const newIngredients = [...ingredients]
      newIngredients[index] = substitution
      setIngredients(newIngredients)
    } else {
      const newIngredients = [...ingredients]
      // @ts-ignore
      newIngredients[input.index][input.property] = input.value
      setIngredients(newIngredients)
    }
    warnChangedIngredient()
  }
  const warnChangedIngredient = () => {
    console.log(autoGeneratedInstructions)
    if (autoGeneratedInstructions) {
      toast({
        title: "Auto Ingredients Changed!",
        description: "You may want to re-generate your instructions",
        status: "warning",
        duration: 3000,
        isClosable: true,
      })
    }
  }

  // Instructions Functions
  const addStep = (event: any) => {
    event.preventDefault()
    if (step === "") {
      return
    }
    if (instructions.find(instruction => instruction === step)) {
      return
    }
    setInstructions([...instructions, step])
    setStep("")
  }
  const deleteStep = (text: string) => {
    setInstructions(instructions.filter(i => i !== text))
  }
  const editStep = (input: { value: string, index: number }) => {
    const newInstructions = [...instructions]
    newInstructions[input.index] = input.value
    setInstructions(newInstructions)
  }

  // Footnotes Functions
  const addFootnote = (event: any) => {
    event.preventDefault()

    if (footnote === "") {
      return
    }
    if (footnotes.find(footnote => footnote === footnote)) {
      return
    }
    setFootnotes([...footnotes, footnote])
    setFootnote("")
  }
  const deleteFootnote = (text: string) => {
    setFootnotes(footnotes.filter(footnote => footnote !== text))
  }
  const editFootnote = (input: { value: string, index: number }) => {
    const newFootnotes = [...footnotes]
    newFootnotes[input.index] = input.value
    setFootnotes(newFootnotes)
  }

  // Add Recipe Functions
  const addRecipe = async () => {
    // Check for empty fields
    if (recipeName === "" || recipeDescription === "" || cookTime === "" || prepTime === "" || ingredients.length === 0 || instructions.length === 0 || !imageUploaded) {
      return toast({
        title: "Missing Fields",
        description: "Please fill out all fields and upload a valid image",
        status: "error",
        duration: 5000,
        isClosable: true,
      })
    }

    await addNewRecipe({
      variables: {
        input: {
          recipe_title: recipeName,
          recipe_desc: recipeDescription,
          prep_time_minutes: parseFloat(prepTime),
          cook_time_minutes: parseFloat(cookTime),
          ingredients: ingredients.map(ingredient => ({
            ingredient: ingredient.ingredient,
            unit: ingredient.unit,
            quantity: ingredient.quantity
          })),
          instructions: instructions.map(instruction => { return { step_desc: instruction } }),
          footnotes,
          original_url: "N/A",
          photo_url: "https://getstamped.co.uk/wp-content/uploads/WebsiteAssets/Placeholder.jpg",
        },
        uuid: uuidState
      }
    })

    apolloClient.cache.evict({ id: "ROOT_QUERY", fieldName: "getSavedRecipes" })
    apolloClient.cache.evict({ id: "ROOT_QUERY", fieldName: "getSavedStatus" })

    toast({
      title: "Recipe Added",
      description: "Your recipe has been added to your cookbook",
      status: "success",
      duration: 5000,
      isClosable: true,
    })

    router.push("/my-cookbook")
  }
  const clearInputs = () => {
    setRecipeName("")
    setRecipeDescription("")
    setCookTime("")
    setPrepTime("")
    setIngredients([])
    setQuantity("")
    setIngredientName("")
    setUnit("")
    setInstructions([])
    setStep("")
    setFootnotes([])
    setFootnote("")
  }

  // Auto-generate Functions
  const generateIngredients = async () => {
    setAutoGeneratedIngredients(true)
    setIngredients([])
    const prompt = `Generate ingredients for the following recipe, in the following format:\n
      quantity unit(grams, ounces, lbs, etc.) ingredientName
      ${recipeName}\n
      ${recipeDescription}\n
      ${instructions.length ? instructions.map(i => i + "\n") : ""} \n
      ${ingredients.length ? ingredients.map(i => `${i.quantity} ${i.unit} ${i.ingredient}`).join("\n") : ""} \n
      
      Output: 
      `

    setAutoIngredienstLoading(true)
    const response = await openai.createCompletion("text-davinci-002", {
      prompt,
      temperature: 0.7,
      max_tokens: 500,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    })
    setAutoIngredienstLoading(false)

    //@ts-ignore
    const output = response.data.choices[0].text.trim().split("\n")
    const tempIngredients: IngredientInputType[] = getIngredientsData(output)

    setIngredients([...ingredients, ...tempIngredients])
  }
  const generateInstructions = async () => {
    setAutoGeneratedInstructions(true)
    setInstructions([])
    const prompt = `Generate instructions for the following recipe:
    ${recipeName}\n
    ${recipeDescription}\n
    ${instructions.length ? instructions.map(i => i + "\n") : ""} \n
    ${ingredients.length ? ingredients.map(i => `${i.quantity} ${i.unit} ${i.ingredient}`).join("\n") : ""} \n

    Output: 
    `

    setAutoInstructionsLoading(true)
    const response = await openai.createCompletion("text-davinci-002", {
      prompt,
      temperature: 0.7,
      max_tokens: 500,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    })
    setAutoInstructionsLoading(false)

    //@ts-ignore
    const output = response.data.choices[0].text.trim().split("\n").filter(i => i !== "")

    setInstructions([...instructions, ...output.map(i => {
      const instruction = i.split(" ")
      instruction.shift()
      return instruction.join(" ")
    })])
  }
  const generateSubstitute = async (input: string) => {
    const response = await openai.createCompletion("text-davinci-002", {
      prompt: `Generate a list of substitutes for ${input} in a ${recipeName} recipe. This recipe is described as "${recipeDescription}". \n\n
      The list must be in the format of: ingredient - ingredient - ingredient \n\n. Ingredients should be in this format: quantity unit(grams, ounces, lbs, etc.) ingredientName. 
      \n\n
      List:
      `,
      temperature: 0.7,
      max_tokens: 500,
      top_p: 1,
      frequency_penalty: 0,
      presence_penalty: 0,
    })

    console.log(response.data)

    //@ts-ignore
    let output = response.data.choices[0].text.trim().split("-")

    const tempIngredients: IngredientInputType[] = getIngredientsData(output)

    return tempIngredients
  }

  return (
    <React.Fragment>
      <Head>
        <title>Create Recipe - Recipe Finder</title>
        <meta name="description" content="Recipe Finder Create Recipe" />
      </Head>

      <Center>
        <h1 className="title">Create Recipe</h1>
      </Center>

      <br />

      { /* Page Title */}
      <Stack direction={"column"} textAlign="center" w="100%">
        <Center>
          <Input placeholder="Recipe Name" w="30em" value={recipeName} onChange={(e) => setRecipeName(e.target.value)} />
        </Center>
        <Center>
          <p style={{ color: "grey", textAlign: "center" }}>By {whoami?.whoami?.user_name}</p>
        </Center>
      </Stack>

      <br />

      <Stack direction={useBreakpointValue({ sm: "column", md: "row" })}>

        { /* Recipe Image and information summary */}
        <Box width={useBreakpointValue({ sm: "100%", md: "50%" })} position="relative">
          {/* Add Button to toggle img tag to imageUpload dropzone */}
          {!imageChange
            ? <Box>
              <Image src={recipe.photo_url} />
              <Button onClick={() => setImageChange(true)}>Replace Image</Button>
            </Box>
            : <ImageUpload uuid={uuidState} setImageUploaded={setImageUploaded} />}
        </Box>
        <Box width={useBreakpointValue({ sm: "100%", md: "50%" })}>
          <Stack className={styles.summaryBox} direction={"column"}>
            <Textarea placeholder="Recipe description" h="15em" value={recipeDescription} onChange={(e) => setRecipeDescription(e.target.value)} />
            <br />
            <Stack direction="row" align="center" w="100%">
              <p><b>Cook time: </b></p>
              <Input w="4em" float="right" type="number" value={cookTime} onChange={(e) => setCookTime(e.target.value)} />
              <p>mins</p>
            </Stack>
            <Stack direction="row" align="center">
              <p><b>Prep time: </b></p>
              <Input w="4em" float="right" type="number" value={prepTime} onChange={(e) => setPrepTime(e.target.value)} />
              <p>mins</p>
            </Stack>
          </Stack>
        </Box>
      </Stack>

      <br />

      <Stack direction={useBreakpointValue({ sm: "column", md: "row" })}>
        { /* Recipe Ingredients */}
        <Stack width={useBreakpointValue({ sm: "100%", md: "50%" })}>
          <h2 className="title">Ingredients</h2>
          <Divider width={useBreakpointValue({ sm: "100%", md: "80%" })} />

          {
            !ingredients.length ? null :
              <ul>
                {
                  ingredients.map((ingredient, index) => {
                    return (
                      <Box key={index} style={{ marginBottom: "1em" }}>
                        <DeletableOption data={ingredient} onDelete={deleteIngredient} index={index} onEdit={editIngredient} generateSubstitute={generateSubstitute} />
                      </Box>
                    )
                  })
                }
              </ul>
          }

          <Stack direction="row" align="center" w="100%">
            <form>
              <Flex justify="space-around">
                <Input placeholder="Quantity" value={quantity} onChange={(e) => setQuantity(e.target.value)} w="20%" />
                <Input placeholder="Unit" value={unit} onChange={(e) => setUnit(e.target.value)} w="15%" />
                <Input placeholder="Ingredient" value={ingredientName} onChange={(e) => setIngredientName(e.target.value)} w="35%" />
                <Button w="20%" onClick={addIngredient} type="submit">Add</Button>
              </Flex>
            </form>
          </Stack>
          <Center>
            <Stack direction={useBreakpointValue({ sm: "column", md: "row" })} justify="space-evenly" width="100%">
              <Button isLoading={autoIngredienstLoading} disabled={!recipeName.length || !recipeDescription.length} onClick={generateIngredients}>Auto Generate Ingredients</Button>
              <Button disabled={!ingredients.length} onClick={() => { setIngredients([]); setAutoGeneratedIngredients(false) }}>Clear</Button>
            </Stack>
          </Center>
        </Stack>

        { /* Recipe Steps */}
        <Stack width={useBreakpointValue({ sm: "100%", md: "50%" })}>
          <h2 className="title">Instructions</h2>
          <Divider width={useBreakpointValue({ sm: "100%", md: "80%" })} />
          {
            instructions.map((step, index) => (
              <Box key={index} style={{ marginBottom: "1em" }}>
                <b><p>Step {index + 1}</p></b>
                <DeletableOption data={step} onDelete={deleteStep} index={index} onEdit={editStep} />
              </Box>
            ))
          }

          <Stack direction="row" align="center" w="100%">
            <form style={{ width: "100%" }}>
              <Flex justify="space-around">
                <Input placeholder="Step" value={step} onChange={(e) => setStep(e.target.value)} w="75%" />
                <Button w="20%" onClick={addStep} type="submit">Add</Button>
              </Flex>
            </form>
          </Stack>
          <Center>
            <Stack direction={useBreakpointValue({ sm: "column", md: "row" })} justify="space-evenly" width="100%">
              <Button isLoading={autoInstructionsLoading} disabled={!recipeName.length || !recipeDescription.length} onClick={generateInstructions}>Auto Generate Instructions</Button>
              <Button disabled={!instructions.length} onClick={() => { setInstructions([]); setAutoGeneratedInstructions(false) }}>Clear</Button>
            </Stack>
          </Center>
        </Stack>
      </Stack>

      <br />

      <Stack>
        <h2 className="title">Footnotes</h2>
        <Divider />
        {
          footnotes?.map((footnote, index) => (
            <Box key={index}>
              <DeletableOption data={footnote} onDelete={deleteFootnote} index={index} onEdit={editFootnote} />
            </Box>
          ))
        }
        <Stack direction="row" align="center" w="100%">
          <form style={{ width: "100%" }}>
            <Flex justify="space-around">
              <Input placeholder="Footnote" value={footnote} onChange={(e) => setFootnote(e.target.value)} w="75%" />
              <Button w="20%" onClick={addFootnote} type="submit">Add</Button>
            </Flex>
          </form>
        </Stack>
      </Stack>

      <br />

      <Center>
        <Stack direction="row">
          <Button size="lg" variant="outline" colorScheme="red" background="transparent" onClick={clearInputs}>Clear</Button>
          <Button size="lg" onClick={addRecipe}>Create Recipe</Button>
        </Stack>
      </Center>

    </React.Fragment>
  )
}

export async function getServerSideProps(context: any) { // Get recipe from url id parameter
  const apolloClient = initializeApollo();
  const recipeId = context.query.id;

  // redirect if recipeId is not a number
  if (isNaN(Number(recipeId))) {
    return {
      redirect: {
        destination: '/404',
        permanent: false
      }
    }
  }

  const recipeData = await apolloClient.query({
    query: GetOneRecipeDocument,
    variables: {
      id: parseInt(recipeId)
    }
  })

  if (!recipeData.data.getOneRecipe) {
    return {
      redirect: {
        destination: '/404',
        permanent: false
      }
    }
  }

  return {
    props: {
      recipe: recipeData.data.getOneRecipe,
    }
  }
}

export default EditRecipe